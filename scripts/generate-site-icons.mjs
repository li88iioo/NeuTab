/**
 * @file generate-site-icons.mjs
 * @description 预构建内置站点图标。
 * 
 * 动机：
 * 1. `react-icons` (si, fa6) 包含数千个图标，直接打包会导致 JS 体积巨大，减慢扩展启动速度。
 * 2. 此脚本在构建时将需要的图标渲染为静态 SVG 文件。
 * 3. 运行后会生成 `assets/site-icons/*.svg` 以及 `utils/iconUrlMap.ts`。
 * 4. 运行时通过 `url:` 导入按需加载这些小体积的静态资源。
 * 5. 支持 `pack: "custom"` 类型，用于自定义 SVG 图标（已预先放置在 assets/site-icons 目录）。
 */

import fs from "node:fs"
import path from "node:path"
import { createRequire } from "node:module"

import React from "react"
import { renderToStaticMarkup } from "react-dom/server"

const require = createRequire(import.meta.url)
const SimpleIcons = require("react-icons/si")
const FontAwesome = require("react-icons/fa6")

const repoRoot = process.cwd()
const catalogPath = path.join(repoRoot, "utils", "iconCatalog.json")
const titleCatalogPath = path.join(repoRoot, "utils", "iconTitleCatalog.json")

const outDir = path.join(repoRoot, "assets", "site-icons")
const outMapPath = path.join(repoRoot, "utils", "iconUrlMap.ts")

/** 确保目录存在 */
const ensureDir = (dir) => fs.mkdirSync(dir, { recursive: true })

/** 
 * 规范化变量名
 * @param {string} s 原始字符串
 * @returns {string} 符合 JS 变量命名规范的字符串
 */
const normalizeVar = (s) => {
	const base = s.replace(/[^a-zA-Z0-9_]/g, "_")
	return /^[0-9]/.test(base) ? `i_${base}` : base
}

/** 
 * 从图标库包中解析具体组件
 * @param {string} pack 库前缀 (si/fa6)
 * @param {string} iconName 图标名称
 */
const resolveIcon = (pack, iconName) => {
	if (pack === "si") return SimpleIcons[iconName]
	if (pack === "fa6") return FontAwesome[iconName]
	return undefined
}

/**
 * 主执行函数
 * @description
 * 1. 读取 domain 和 title 的图标配置表。
 * 2. 遍历配置，调用 react-dom/server 将图标组件渲染为带颜色的 SVG。
 * 3. 写入文件到 assets 目录并生成对应的 TS 映射表。
 */
const main = () => {
	// 读取域名匹配目录
	const catalog = JSON.parse(fs.readFileSync(catalogPath, "utf8"))
	const domainEntries = Object.entries(catalog).map(([domain, entry]) => ({
		key: domain,
		kind: "domain",
		pack: entry.pack,
		iconName: entry.iconName,
		color: entry.color
	}))

	// 读取标题匹配目录 (隐私友好型，不暴露具体私有域名)
	const titleCatalog = fs.existsSync(titleCatalogPath)
		? JSON.parse(fs.readFileSync(titleCatalogPath, "utf8"))
		: {}
	const titleEntries = Object.entries(titleCatalog).map(([titleKey, entry]) => ({
		key: titleKey,
		kind: "title",
		pack: entry.pack,
		iconName: entry.iconName,
		color: entry.color
	}))

	const allEntries = [...domainEntries, ...titleEntries]

	console.log(
		`Found ${domainEntries.length} domain icon entries + ${titleEntries.length} title icon entries`
	)

	ensureDir(outDir)

	// assets 缓存: assetKey -> { fileName, varName }
	const assets = new Map()
	// 域名到资源键映射
	const domainToAssetKey = new Map()
	// 标题到资源键映射
	const titleToAssetKey = new Map()

	for (const e of allEntries) {
		// 特殊处理: Google multicolor 图标在前端代码中以 SVG 形式硬编码，此处跳过
		if (e.color === "gradient-google") continue

		// 相同的图标+颜色组合只需生成一次
		const colorKey = e.color.replace(/^#/, "").toLowerCase()
		const assetKey = `${e.iconName}__${colorKey}`
		if (e.kind === "domain") {
			domainToAssetKey.set(e.key, assetKey)
		} else {
			titleToAssetKey.set(e.key, assetKey)
		}

		if (assets.has(assetKey)) continue

		const fileName = `${e.iconName}-${colorKey}.svg`
		const varName = normalizeVar(`icon_${e.iconName}_${colorKey}`)

		// 处理自定义图标（pack: "custom"）- SVG 文件已预先存在
		if (e.pack === "custom") {
			const customFilePath = path.join(outDir, fileName)
			if (fs.existsSync(customFilePath)) {
				assets.set(assetKey, { fileName, varName })
				console.log(`Registered custom icon: ${fileName}`)
			} else {
				console.warn(`Warning: Custom icon file not found: ${fileName}`)
			}
			continue
		}

		// 处理 react-icons 图标
		const Icon = resolveIcon(e.pack, e.iconName)
		if (!Icon) continue

		assets.set(assetKey, { fileName, varName })

		// 静态渲染 SVG 并应用颜色
		const svg = renderToStaticMarkup(React.createElement(Icon, { size: 64, style: { color: e.color } }))
		fs.writeFileSync(path.join(outDir, fileName), svg + "\n", "utf8")
	}

	// 确定性输出（排序），保持 Git diff 干净
	const sortedAssets = [...assets.values()].sort((a, b) => a.fileName.localeCompare(b.fileName))
	const sortedDomains = [...domainToAssetKey.entries()].sort(([a], [b]) => a.localeCompare(b))
	const sortedTitles = [...titleToAssetKey.entries()].sort(([a], [b]) => a.localeCompare(b))

	// 生成 Import 语句映射到 Plasmo 的 url 导入
	const imports = sortedAssets
		.map((a) => `import ${a.varName} from \"url:../assets/site-icons/${a.fileName}\"`)
		.join("\n")

	const lines = []
	lines.push("// This file is generated by `scripts/generate-site-icons.mjs`. Do not edit by hand.")
	lines.push("")
	lines.push(imports)
	lines.push("")

	// 导出域名映射表
	lines.push("export const ICON_URL_MAP: Record<string, string> = {")
	for (const [domain, assetKey] of sortedDomains) {
		const asset = assets.get(assetKey)
		if (!asset) continue
		lines.push(`  \"${domain}\": ${asset.varName},`)
	}
	lines.push("}")
	lines.push("")

	// 导出标题映射表
	lines.push("export const ICON_TITLE_MAP: Record<string, string> = {")
	for (const [titleKey, assetKey] of sortedTitles) {
		const asset = assets.get(assetKey)
		if (!asset) continue
		lines.push(`  \"${titleKey}\": ${asset.varName},`)
	}
	lines.push("}")
	lines.push("")

	fs.writeFileSync(outMapPath, lines.join("\n"), "utf8")

	console.log(`Generated ${sortedAssets.length} SVG assets into ${path.relative(repoRoot, outDir)}`)
	console.log(`Generated ${path.relative(repoRoot, outMapPath)}`)
}

main()
